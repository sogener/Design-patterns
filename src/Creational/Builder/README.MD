# Builder (Строитель)

**Строитель -** Паттерн проектирования который позволяет создавать легкие обьекты пошагово. <br>

Строитель даёт возможность использовать один и тот же код строительства, для получения разных представлений обьектов.

### Какую проблему решает паттерн?

Строитель предлагает вынести конструирование обьекта за пределы собственного класса, поручив это дело отдельным обьектам, называемым **строителями**.

Паттерн предлагает разбить процесс конструирования обьекта на отдельные шаги.

---
### UML Diagram
![builder](https://user-images.githubusercontent.com/50992188/157176022-a4e4f217-152b-46d4-a363-9a91f19c9a3e.png)

---
### Например:
1. Построить стены
2. Вставить двери
3. и т.д

Чтобы создать обьект, нужно поочерёдно вызывать методы строителя.

Причём **не нужно запускать все шаги**, а только те, что нужны для производства обьекта определённой конфигурации.

---
## Идём дальше
Зачастую, один и тот же шаг строительства может отличаться для разных вариаций производимых обьектов.

Например, деревянный дом потребует строительства стен из дерева, а каменный - из камня.

### Решение
В этом случае, можно создать несколько классов строителей, выполняющих одни и те же шаги по-разному.

Используя этих строителей в одном и том же строительном процессе, вы сможете получать на выходе различные обьекты.

### Например
**Первый строитель** - делает стены из дерева и стекла. <br>
**Второй строитель** - делает стены из камня и железа. <br>
**Третий** - из алмазов и золота.

### Обязательно!
Код, который вызывает шаги строительства должен работать со строителями через общий интерфейс, чтобы их можно было свободно взаимозаменять.

---
## Директор
Можно пойти дальше и выделить вызовы методов строителя в отдельный класс, называемый **«Директором»**.

В этом случае, **директор** будет задавать порядок шагов строительства, а **строитель** выполнять их.

Отдельный класс **директора** не является строго
обязательным. Вы можете вызывать методы **строителя** и
напрямую из клиентского кода. 

Тем не менее, **директор** полезен, если у вас есть несколько способов
конструирования продуктов, отличающихся порядком и
наличием шагов конструирования. В этом случае, вы
сможете объединить всю эту логику в **одном классе**.
