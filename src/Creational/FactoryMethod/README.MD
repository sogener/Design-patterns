# Factory Method (Фабричный метод)

**Фабричный метод -** порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в
суперклассе, позволяя подклассам изменять тип создаваемых объектов.

### Какую проблему решает паттерн?

Плюс **фабричного метода** заключается в том, что можно создать его подкласс для реализации различных способов создания объектов.

Для простых ситуаций можно использовать **интерфейс**, вместо **абстрактного класса**.

---

### UML Diagram
![Screenshot from 2022-03-08 12-31-18](https://user-images.githubusercontent.com/50992188/157188540-08937594-9e4b-4270-994c-9466e0a340c8.png)

---

# How to run tests?
./vendor/bin/phpunit src/Creational/FactoryMethod/Tests

---

### Применимость

1. Когда заранее неизвестны типы и зависимости обьектов, с которыми должен работать ваш код.

**Фабричный метод** отделяет код производства транспорта от остального кода, который эти транспорты использует.
Благодаря этому, код производства можно расширять, не трогая основной код.

Так, чтобы добавить поддержку нового продукта, вам нужно создать новый подкласс и определить в нём **фабричный метод**,
возвращая оттуда экземпляр **нового продукта**.

2. Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки.
3. Когда вы хотите экономить системные ресурсы, повторно используя уже созданные объекты, вместо создания новых.

---

### Преимущества и недостатки

1. Избавляет класс от **привязки** к конкретным классам.
2. Выделяет код производства транспорта **в одно место, упрощая поддержку кода**.
3. **Упрощает** добавление новых продуктов в программу.
4. **Реализует принцип** открытости/закрытости.
5. Может привести к созданию **больших параллельных иерархий классов**, так как для каждого транспорта надо создать **
   свой подкласс создателя**.

---

### Отношения с другими паттернами

Многие архитектуры начинаются с применения **Фабричного метода** (более простого и расширяемого через подклассы)
и эволюционируют в сторону **Абстрактной фабрики, Прототипа или Строителя** (более гибких, но и более сложных).

Классы **Абстрактной фабрики** чаще всего реализуются с помощью **Фабричного метода**, хотя они могут быть построены и
на основе **Прототипа**.

**Фабричный метод** можно использовать вместе с
**Итератором**, чтобы подклассы коллекций могли создавать подходящие им итераторы.

**Прототип** не опирается на наследование, но ему нужна сложная операция инициализации. **Фабричный метод**
наоборот, построен на наследовании, но не требует сложной инициализации.

**Фабричный метод** можно рассматривать как частный случай **Шаблонного метода**. Кроме того, **Фабричный метод
Порождающие паттерны / Фабричный метод**
нередко бывает частью большого класса с **Шаблонными методами**.
